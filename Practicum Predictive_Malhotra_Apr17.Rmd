---
title: "Practicum Predictive"
author: "Team"
date: "3/27/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r library, message  = F}
library(tidyverse)
library(lubridate)
library(ggthemes)
library(data.table)
library(scales)
library(forecast)
library(imputeTS)
```

```{r new, cache=T}
newwo = read_csv("workorder_clean.csv", guess_max = 1500000)
```

## Data Manipulations

```{r date}
requested = newwo %>% 
  mutate(yearrequested = year(daterequested),
         monthrequested = month(daterequested),
         dayrequested = day(daterequested)) %>%
  filter(yearrequested < 2020, yearrequested > 2000) %>%
  mutate(ymrequested = make_date(yearrequested, monthrequested),
         ymdrequested = make_date(yearrequested, monthrequested, dayrequested)) %>%
  mutate(yearcompleted = year(actualcompletiondate),
         monthcompleted = month(actualcompletiondate),
         daycompleted = day(actualcompletiondate)) %>%
  filter(yearcompleted < 2020, yearcompleted > 2000) %>%
  mutate(ymcompleted = make_date(yearcompleted, monthcompleted),
         ymdcompleted = make_date(yearcompleted, monthcompleted, daycompleted))

```

```{r priorityts}
priority = requested %>% select(craftdescription, craftgroup, daterequested, datecreated, actualcompletiondate, laststatuschange, currentstatus, prioritydescription, ispreventmaint, ymrequested, ymcompleted) %>%
  filter(currentstatus %in% c("Completed", "Closed")) %>%
  filter(prioritydescription != "OTHER") %>%
  filter(!is.na(daterequested), !is.na(datecreated), !is.na(laststatuschange)) %>%
  mutate(createffi = abs(as.numeric(round((datecreated - daterequested)/3600), digits = 2)),
         totaleffi = abs(as.numeric(round((actualcompletiondate - daterequested)/3600), digits = 2)))

priority
```

## Cost Analysis

### 1. Subsets

```{r cost}
zerocost = newwo %>% filter(actualcosts == 0, 
                            currentstatus == "Completed") %>% 
  select(craftgroup, prioritydescription) %>%
  group_by(craftgroup) %>%
  summarize(n = n())

costdata = requested %>% filter(currentstatus %in% c("Completed", "Closed"),
                                !is.na(daterequested), 
                                !is.na(datecreated), 
                                !is.na(laststatuschange)) %>%
  filter(prioritydescription != "OTHER") %>%
  select(actualcosts, craftgroup, daterequested, actualcompletiondate, prioritydescription, ymrequested, ymcompleted) %>% 
  mutate(totaleffi = abs(as.numeric(round((actualcompletiondate - daterequested)/3600), digits = 2)))

zerocost = costdata %>% filter(actualcosts == 0)
nonzerocost = costdata %>% filter(actualcosts != 0)
normalcost = costdata %>% filter(actualcosts < 3500, actualcosts > 0)
mediumcost = costdata %>% filter(actualcosts >= 3500, actualcosts <= 10000)
highcost = costdata %>% filter(actualcosts > 10000)
```

### 2. Regression

```{r costreg}
regall = lm(actualcosts ~ craftgroup + totaleffi + prioritydescription, data = costdata)
summary(regall)

regnonzero = lm(actualcosts ~ craftgroup + totaleffi + prioritydescription, data = nonzerocost)
summary(regnonzero)

regnormal = lm(actualcosts ~ craftgroup + totaleffi + prioritydescription, data = normalcost)
summary(regnormal)

regmedium = lm(actualcosts ~ craftgroup + totaleffi + prioritydescription, data = mediumcost)
summary(regmedium)

reghigh = lm(actualcosts ~ craftgroup + totaleffi + prioritydescription, data = highcost)
summary(reghigh)
```

### 3. Time Series 

#### Functions

```{r MSEfunc}

#The following functions are used to identify the time series method that gives the lowest test MSE

##For Number of Work Orders by Craft Group

COUNT_TS_MSE = function(craftgroup) {
  tsdata = nonzerocost %>% filter(craftgroup == !!craftgroup) %>% 
    group_by(ymrequested) %>% 
    summarize(count = n()) %>%
    full_join(wocount, by = "ymrequested") %>%
    na_replace(fill = 0) %>%
    select(-wocount) %>%
    arrange(ymrequested)
  
  ts = ts(tsdata$count, 
          start = c(2001,1), 
          end = c(2019,6), 
          frequency = 12)

  
  train.periods = 155
  test.periods = 67
  cycle=12
  
  ts.training <- ts(tsdata$count[1:train.periods], start = c(2001,1), end = c(2019,6), frequency = 12)
  
  ts.training.SESmodel <- HoltWinters(ts.training, beta=FALSE, gamma=FALSE)
  ts.training.DESmodel <- HoltWinters(ts.training, gamma=FALSE)
  ts.training.HWmodel <- HoltWinters(ts.training)
  
  ts.SESmodel <- HoltWinters(ts,
                                       alpha=ts.training.SESmodel$alpha, 
                                       beta=FALSE, 
                                       gamma=FALSE)
  ts.DESmodel <- HoltWinters(ts, 
                                       alpha=ts.training.DESmodel$alpha, 
                                       beta=ts.training.DESmodel$beta, 
                                       gamma=FALSE)
  ts.HWmodel <- HoltWinters(ts, 
                                      alpha=ts.training.HWmodel$alpha, 
                                      beta=ts.training.HWmodel$beta, 
                                      gamma=ts.training.HWmodel$gamma)
  
  data.start <- train.periods + 1
  data.end <- train.periods + test.periods
  
  fit.start <- train.periods 
  fit.end <- train.periods + test.periods - 1
  
  SES.MSE <- sum((ts.SESmodel$fitted[fit.start:fit.end] - ts[data.start:data.end])^2)/(test.periods)
  
  fit.start <- train.periods - 1 
  fit.end <- train.periods + test.periods - 2
  
  DES.MSE <- sum((ts.DESmodel$fitted[fit.start:fit.end] - ts[data.start:data.end])^2)/(test.periods)
  
  fit.start <- train.periods - cycle + 1 
  fit.end <- train.periods + test.periods - cycle
  
  HW.MSE <- sum((ts.HWmodel$fitted[fit.start:fit.end] - ts[fit.start:fit.end])^2)/(test.periods)
  
  MSE = data.frame(SES.MSE, DES.MSE, HW.MSE)
  
  print(MSE)
  print(paste("The minimum MSE is", 
              names(MSE)[which.min(MSE)],
              "=",
              round(MSE[which.min(MSE)]))) 
  
}

#For Total Cost of Work Orders in each Craft Group

COST_TS_MSE = function(craftgroup) {
  tsdata = nonzerocost %>% filter(craftgroup == !!craftgroup) %>% 
    group_by(ymrequested) %>% 
    summarize(totalcost = sum(actualcosts))%>%
    full_join(wocount, by = "ymrequested") %>%
    na_replace(fill = 0) %>%
    select(-wocount) %>%
    arrange(ymrequested)

  ts = ts(tsdata$totalcost, 
          start = c(2001,1), 
          end = c(2019,6), 
          frequency = 12)
  
  
  train.periods = 155
  test.periods = 67
  cycle=12
  
  ts.training <- ts(tsdata$totalcost[1:train.periods], start = c(2001,1), end = c(2019,6), frequency = 12)
  
  ts.training.SESmodel <- HoltWinters(ts.training, beta=FALSE, gamma=FALSE)
  ts.training.DESmodel <- HoltWinters(ts.training, gamma=FALSE)
  ts.training.HWmodel <- HoltWinters(ts.training)
  
  ts.SESmodel <- HoltWinters(ts,
                             alpha=ts.training.SESmodel$alpha, 
                             beta=FALSE, 
                             gamma=FALSE)
  ts.DESmodel <- HoltWinters(ts, 
                             alpha=ts.training.DESmodel$alpha, 
                             beta=ts.training.DESmodel$beta, 
                             gamma=FALSE)
  ts.HWmodel <- HoltWinters(ts, 
                            alpha=ts.training.HWmodel$alpha, 
                            beta=ts.training.HWmodel$beta, 
                            gamma=ts.training.HWmodel$gamma)
  
  data.start <- train.periods + 1
  data.end <- train.periods + test.periods
  
  fit.start <- train.periods 
  fit.end <- train.periods + test.periods - 1
  
  SES.MSE <- sum((ts.SESmodel$fitted[fit.start:fit.end] - ts[data.start:data.end])^2)/(test.periods)
  
  fit.start <- train.periods - 1 
  fit.end <- train.periods + test.periods - 2
  
  DES.MSE <- sum((ts.DESmodel$fitted[fit.start:fit.end] - ts[data.start:data.end])^2)/(test.periods)
  
  fit.start <- train.periods - cycle + 1 
  fit.end <- train.periods + test.periods - cycle
  
  HW.MSE <- sum((ts.HWmodel$fitted[fit.start:fit.end] - ts[fit.start:fit.end])^2)/(test.periods)
  
  MSE = data.frame(SES.MSE, DES.MSE, HW.MSE)
  
  print(MSE)
  print(paste("The minimum MSE is", 
              names(MSE)[which.min(MSE)],
              "=",
              round(MSE[which.min(MSE)]))) 
  
}
```

```{r predSES}
SES.prediction = function(craftgroup) {
  tsdata = nonzerocost %>% filter(craftgroup == !!craftgroup) %>% 
    group_by(ymrequested) %>% 
    summarize(count = n()) %>%
    full_join(wocount, by = "ymrequested") %>%
    na_replace(fill = 0) %>%
    select(-wocount) %>%
    arrange(ymrequested)
  
  ts = ts(tsdata$count, 
          start = c(2001,1), 
          end = c(2019,6), 
          frequency = 12)
  
  
  train.periods = 155
  test.periods = 67
  cycle=12
  
  ts.training <- ts(tsdata$count[1:train.periods], start = c(2001,1), end = c(2019,6), frequency = 12)
  
  ts.training.SESmodel <- HoltWinters(ts.training, beta=FALSE, gamma=FALSE)
  
  ts.SESmodel <- HoltWinters(ts,
                             alpha=ts.training.SESmodel$alpha, 
                             beta=FALSE, 
                             gamma=FALSE)
  
  forec = forecast(ts.SESmodel, 18)
  SES.plot = plot(ts.SESmodel)
  forecast.plot = plot(forec, main = "Single Exponential Smoothing Forecast for 2019-2020")
  forecast.plot
  
}
```

```{r predDES}
DES.prediction = function(craftgroup) {
  tsdata = nonzerocost %>% filter(craftgroup == !!craftgroup) %>% 
    group_by(ymrequested) %>% 
    summarize(count = n()) %>%
    full_join(wocount, by = "ymrequested") %>%
    na_replace(fill = 0) %>%
    select(-wocount) %>%
    arrange(ymrequested)
  
  ts = ts(tsdata$count, 
          start = c(2001,1), 
          end = c(2019,6), 
          frequency = 12)
  
  
  train.periods = 155
  test.periods = 67
  cycle=12
  
  ts.training <- ts(tsdata$count[1:train.periods], start = c(2001,1), end = c(2019,6), frequency = 12)
  
  ts.training.DESmodel <- HoltWinters(ts.training, gamma=FALSE)
  
  ts.DESmodel <- HoltWinters(ts,
                             alpha=ts.training.DESmodel$alpha, 
                             beta=ts.training.DESmodel$beta, 
                             gamma=FALSE)
  
  forec = forecast(ts.DESmodel, 18)
  DES.plot = plot(ts.DESmodel)
  forecast.plot = plot(forec, main = "Double Exponential Smoothing Forecast for 2019-2020")
  forecast.plot
  
}
```

```{r predHW}
HW.prediction = function(craftgroup) {
  tsdata = nonzerocost %>% filter(craftgroup == !!craftgroup) %>% 
    group_by(ymrequested) %>% 
    summarize(count = n()) %>%
    full_join(wocount, by = "ymrequested") %>%
    na_replace(fill = 0) %>%
    select(-wocount) %>%
    arrange(ymrequested)
  
  ts = ts(tsdata$count, 
          start = c(2001,1), 
          end = c(2019,6), 
          frequency = 12)
  
  
  train.periods = 155
  test.periods = 67
  cycle=12
  
  ts.training <- ts(tsdata$count[1:train.periods], start = c(2001,1), end = c(2019,6), frequency = 12)
  
  ts.training.HWmodel <- HoltWinters(ts.training)
  
  ts.HWmodel <- HoltWinters(ts,
                             alpha=ts.training.HWmodel$alpha, 
                             beta=ts.training.HWmodel$beta, 
                             gamma=ts.training.HWmodel$gamma)
  
  forec = forecast(ts.HWmodel, 18)
  HW.plot = plot(ts.HWmodel)
  forecast.plot = plot(forec, main = "Holtwinter Seasonality Forecast for 2019-2020")
  list(HW.plot, forecast.plot)
  
}
```

#### 3.1. Time series by requested date to predict number of orders requested

**3.1.1 All Orders for All Crafts**

```{r wocount}
wocount = nonzerocost  %>% group_by(ymrequested) %>% summarize(wocount = n())
```

```{r wocountts}
wocountts = ts(wocount$wocount, start = c(2001,1), end = c(2019,8), frequency = 12)
plot(wocountts)
```

```{r wocountts_testMSE_allcrafts}
train.periods <- 155
test.periods <- length(wocountts) - train.periods
cycle <- 12

wocountts.training <- ts(wocount$wocount[1:train.periods], start = c(2001,1), end = c(2019,8), frequency = 12)

wocountts.training.SESmodel <- HoltWinters(wocountts.training, beta=FALSE, gamma=FALSE)
wocountts.training.DESmodel <- HoltWinters(wocountts.training, gamma=FALSE)
wocountts.training.HWmodel <- HoltWinters(wocountts.training)

wocountts.SESmodel <- HoltWinters(wocountts,
                          alpha=wocountts.training.SESmodel$alpha, 
                          beta=FALSE, 
                          gamma=FALSE)
wocountts.DESmodel <- HoltWinters(wocountts, 
                          alpha=wocountts.training.DESmodel$alpha, 
                          beta=wocountts.training.DESmodel$beta, 
                          gamma=FALSE)
wocountts.HWmodel <- HoltWinters(wocountts, 
                         alpha=wocountts.training.HWmodel$alpha, 
                         beta=wocountts.training.HWmodel$beta, 
                         gamma=wocountts.training.HWmodel$gamma)

data.start <- train.periods + 1
data.end <- train.periods + test.periods

fit.start <- train.periods 
fit.end <- train.periods + test.periods - 1

SES.MSE <- sum((wocountts.SESmodel$fitted[fit.start:fit.end] - wocountts[data.start:data.end])^2)/(test.periods)

fit.start <- train.periods - 1 
fit.end <- train.periods + test.periods - 2

DES.MSE <- sum((wocountts.DESmodel$fitted[fit.start:fit.end] - wocountts[data.start:data.end])^2)/(test.periods)

fit.start <- train.periods - cycle + 1 
fit.end <- train.periods + test.periods - cycle

HW.MSE <- sum((wocountts.HWmodel$fitted[fit.start:fit.end] - wocountts[fit.start:fit.end])^2)/(test.periods)

cat(paste("SES MSE =", SES.MSE, "\nDES MSE =", DES.MSE, "\nHW MSE =", HW.MSE))
```

```{r wocountts_predict_allcrafts}
plot(wocountts.HWmodel)
wocount_2020_HW = forecast(wocountts.HWmodel, 15)
plot(wocount_2020_HW, main = "Holtwinters Forecast for 2019-2020")
```

**3.1.2 Plumbing** 

```{r wocountts_predict_plumb}
COUNT_TS_MSE("PLUMBING/RESTROOM")

HW.prediction("PLUMBING/RESTROOM")
```

**3.1.3 Furniture** 

```{r wocountts_predict_furniture}
COUNT_TS_MSE("FURNITURES/UTILITIES/APPLIANCES")

HW.prediction("FURNITURES/UTILITIES/APPLIANCES")
```


**3.1.3 Security**

```{r wocountts_predict_security}
COUNT_TS_MSE("HEALTH/SAFETY/SECURITY")

HW.prediction("HEALTH/SAFETY/SECURITY")
```

**3.1.4 Electricity/Energy**

```{r wocountts_predict_energy}
COUNT_TS_MSE("ELECTRICITY/ENERGY")

HW.prediction("ELECTRICITY/ENERGY")
```

**3.1.5 Outdoors**

```{r wocountts_predict_outdoor}
COUNT_TS_MSE("OUTDOORS")

HW.prediction("OUTDOORS")
```

**3.1.6 Vehicle/Transportation/Delivery** 

```{r wocountts_predict_transport}
COUNT_TS_MSE("VEHICLE/TRANSPORTATION/DELIVERY")

DES.prediction("VEHICLE/TRANSPORTATION/DELIVERY")
```

**3.1.7 Cleaning/Sanitization** 

```{r wocountts_predict_clean}
COUNT_TS_MSE("CLEANING/SANITIZATION")

DES.prediction("CLEANING/SANITIZATION")
```

**3.1.8 Construction/Building** 

```{r wocountts_predict_construct}
COUNT_TS_MSE("CONSTRUCTION/BUILDING")

DES.prediction("CONSTRUCTION/BUILDING")
```


**3.1.9 Event/Recreation/Food and Beverages**

```{r wocountts_predict_event}
COUNT_TS_MSE("EVENT/RECREATION/F&B")

HW.prediction("EVENT/RECREATION/F&B")
```


**3.1.10 Plant and Materials**

```{r wocountts_predict_plant}
COUNT_TS_MSE("PLANT/MATERIALS")

HW.prediction("PLANT/MATERIALS")
```

**3.1.11 Personnel and Training**

```{r wocountts_predict_personnel}
COUNT_TS_MSE("ADMIN/PERSONNEL/TRAINING")

DES.prediction("ADMIN/PERSONNEL/TRAINING")
```

**3.1.12 Preventive/Scheduled** 

```{r wocountts_predict_PM}
COUNT_TS_MSE("PREVENTIVE/SCHEDULED")

SES.prediction("PREVENTIVE/SCHEDULED")
```

**3.1.13 Inspection** 

```{r wocountts_predict_inspect}
COUNT_TS_MSE("INSPECTION")

DES.prediction("INSPECTION")
```

**3.1.14 IT/Network** 

```{r wocountts_predict_IT}
COUNT_TS_MSE("IT/NETWORK")

HW.prediction("IT/NETWORK")
```


**3.1.15 Contract**

```{r wocountts_predict_contract}
COUNT_TS_MSE("CONTRACT")

SES.prediction("CONTRACT")
```

**3.1.16 SOS**

```{r wocountts_predict_SOS}
COUNT_TS_MSE("SOS")

SES.prediction("SOS")
```


**3.1.17 Others** 

```{r wocountts_predict_other}
othercount = nonzerocost %>% filter(craftgroup %in% c("CODES", "OTHER", "UNCLEAR/TBD")) %>% 
  group_by(ymrequested) %>% 
  summarize(wocount = n())
othercountts = ts(othercount$wocount, start = c(2001,4), end = c(2019,6), frequency = 12)
plot(othercountts)
```

```{r wocountts_testMSE_other}
test.periods <- length(othercountts) - train.periods

othercountts.training <- ts(othercount$wocount[1:train.periods], start = c(2001,1), end = c(2019,6), frequency = 12)

othercountts.training.SESmodel <- HoltWinters(othercountts.training, beta=FALSE, gamma=FALSE)
othercountts.training.DESmodel <- HoltWinters(othercountts.training, gamma=FALSE)
othercountts.training.HWmodel <- HoltWinters(othercountts.training)

othercountts.SESmodel <- HoltWinters(othercountts,
                          alpha=othercountts.training.SESmodel$alpha, 
                          beta=FALSE, 
                          gamma=FALSE)
othercountts.DESmodel <- HoltWinters(othercountts, 
                          alpha=othercountts.training.DESmodel$alpha, 
                          beta=othercountts.training.DESmodel$beta, 
                          gamma=FALSE)
othercountts.HWmodel <- HoltWinters(othercountts, 
                         alpha=othercountts.training.HWmodel$alpha, 
                         beta=othercountts.training.HWmodel$beta, 
                         gamma=othercountts.training.HWmodel$gamma)

data.start <- train.periods + 1
data.end <- train.periods + test.periods

fit.start <- train.periods 
fit.end <- train.periods + test.periods - 1

SES.MSE <- sum((othercountts.SESmodel$fitted[fit.start:fit.end] - othercountts[data.start:data.end])^2)/(test.periods)

fit.start <- train.periods - 1 
fit.end <- train.periods + test.periods - 2

DES.MSE <- sum((othercountts.DESmodel$fitted[fit.start:fit.end] - othercountts[data.start:data.end])^2)/(test.periods)

fit.start <- train.periods - cycle + 1 
fit.end <- train.periods + test.periods - cycle

HW.MSE <- sum((othercountts.HWmodel$fitted[fit.start:fit.end] - othercountts[fit.start:fit.end])^2)/(test.periods)

cat(paste("SES MSE =", SES.MSE, "\nDES MSE =", DES.MSE, "\nHW MSE =", HW.MSE))
```

```{r wocountts_predict_other}
plot(othercountts.HWmodel)
othercount_2020_HW = forecast(othercountts.HWmodel, 15)
plot(othercount_2020_HW, main = "Holtwinters other Forecast for 2019-2020")
```

3.2. Time Series by requested date to predict total costs

```{r setupts}
costts = nonzerocost %>% 
  group_by(ymrequested) %>% 
  summarize(totalcost = sum(actualcosts))

normalcostts = normalcost %>% select(actualcosts, ymrequested)
mediumcostts = mediumcost %>% select(actualcosts, ymrequested)
highcostts = highcost %>% select(actualcosts, ymrequested)
```

```{r costts}
totalts = ts(costts$totalcost, start = c(2001,1), end = c(2019,8), frequency = 12)
plot(totalts)
```

```{r costfunctions}
COST_TS_MSE = function(craftgroup) {
  tsdata = nonzerocost %>% filter(craftgroup == !!craftgroup) %>% 
    group_by(ymrequested) %>% 
    summarize(totalcost = sum(actualcosts))%>%
    full_join(wocount, by = "ymrequested") %>%
    na_replace(fill = 0) %>%
    select(-wocount) %>%
    arrange(ymrequested)

  ts = ts(tsdata$totalcost, 
          start = c(2001,1), 
          end = c(2019,6), 
          frequency = 12)
  
  
  train.periods = 155
  test.periods = 67
  cycle = 12
  
  ts.training <- ts(tsdata$totalcost[1:train.periods], start = c(2001,1), end = c(2019,6), frequency = 12)
  
  ts.training.SESmodel <- HoltWinters(ts.training, beta=FALSE, gamma=FALSE)
  ts.training.DESmodel <- HoltWinters(ts.training, gamma=FALSE)
  ts.training.HWmodel <- HoltWinters(ts.training)
  
  ts.SESmodel <- HoltWinters(ts,
                             alpha=ts.training.SESmodel$alpha, 
                             beta=FALSE, 
                             gamma=FALSE)
  ts.DESmodel <- HoltWinters(ts, 
                             alpha=ts.training.DESmodel$alpha, 
                             beta=ts.training.DESmodel$beta, 
                             gamma=FALSE)
  ts.HWmodel <- HoltWinters(ts, 
                            alpha=ts.training.HWmodel$alpha, 
                            beta=ts.training.HWmodel$beta, 
                            gamma=ts.training.HWmodel$gamma)
  
  data.start <- train.periods + 1
  data.end <- train.periods + test.periods
  
  fit.start <- train.periods 
  fit.end <- train.periods + test.periods - 1
  
  SES.MSE <- sum((ts.SESmodel$fitted[fit.start:fit.end] - ts[data.start:data.end])^2)/(test.periods)
  
  fit.start <- train.periods - 1 
  fit.end <- train.periods + test.periods - 2
  
  DES.MSE <- sum((ts.DESmodel$fitted[fit.start:fit.end] - ts[data.start:data.end])^2)/(test.periods)
  
  fit.start <- train.periods - cycle + 1 
  fit.end <- train.periods + test.periods - cycle
  
  HW.MSE <- sum((ts.HWmodel$fitted[fit.start:fit.end] - ts[fit.start:fit.end])^2)/(test.periods)
  
  MSE = data.frame(SES.MSE, DES.MSE, HW.MSE)
  
  print(MSE)
  print(paste("The minimum MSE is", 
              names(MSE)[which.min(MSE)],
              "=",
              round(MSE[which.min(MSE)]))) 
  
}

### SES function for cost

SES.prediction.cost = function(craftgroup) {
  tsdata = nonzerocost %>% filter(craftgroup == !!craftgroup) %>% 
    group_by(ymrequested) %>% 
    summarize(totalcost = sum(actualcosts)) %>%
    full_join(wocount, by = "ymrequested") %>%
    na_replace(fill = 0) %>%
    select(-wocount) %>%
    arrange(ymrequested)
  
  ts = ts(tsdata$totalcost, 
          start = c(2001,1), 
          end = c(2019,6), 
          frequency = 12)
  
  
  train.periods = 155
  test.periods = 67
  cycle = 12
  
  ts.training <- ts(tsdata$totalcost[1:train.periods], start = c(2001,1), end = c(2019,6), frequency = 12)
  
  ts.training.SESmodel <- HoltWinters(ts.training, beta=FALSE, gamma=FALSE)
  
  ts.SESmodel <- HoltWinters(ts,
                             alpha=ts.training.SESmodel$alpha, 
                             beta=FALSE, 
                             gamma=FALSE)
  
  forec = forecast(ts.SESmodel, 18)
  SES.plot = plot(ts.SESmodel)
  forecast.plot = plot(forec, main = "Single Exponential Smoothing Cost Forecast for 2019-2020")
  list(SES.plot, forecast.plot)
  
}

###DES function for cost

DES.prediction.cost = function(craftgroup) {
  tsdata = nonzerocost %>% filter(craftgroup == !!craftgroup) %>% 
    group_by(ymrequested) %>% 
    summarize(totalcost = sum(actualcosts)) %>%
    full_join(wocount, by = "ymrequested") %>%
    na_replace(fill = 0) %>%
    select(-wocount) %>%
    arrange(ymrequested)
  
  ts = ts(tsdata$totalcost, 
          start = c(2001,1), 
          end = c(2019,6), 
          frequency = 12)
  
  
  train.periods = 155
  test.periods = 67
  cycle = 12
  
  ts.training <- ts(tsdata$totalcost[1:train.periods], start = c(2001,1), end = c(2019,6), frequency = 12)
  
  ts.training.DESmodel <- HoltWinters(ts.training, gamma=FALSE)
  
  ts.DESmodel <- HoltWinters(ts,
                             alpha=ts.training.DESmodel$alpha, 
                             beta=ts.training.DESmodel$beta, 
                             gamma=FALSE)
  
  forec = forecast(ts.DESmodel, 18)
  DES.plot = plot(ts.DESmodel)
  forecast.plot = plot(forec, main = "Double Exponential Smoothing Cost Forecast for 2019-2020")
  forecast.plot
  
}

### HW function for cost

HW.prediction.cost = function(craftgroup) {
  tsdata = nonzerocost %>% filter(craftgroup == !!craftgroup) %>% 
    group_by(ymrequested) %>% 
    summarize(totalcost = sum(actualcosts)) %>%
    full_join(wocount, by = "ymrequested") %>%
    na_replace(fill = 0) %>%
    select(-wocount) %>%
    arrange(ymrequested)
  
  ts = ts(tsdata$totalcost, 
          start = c(2001,1), 
          end = c(2019,6), 
          frequency = 12)
  
  
  train.periods = 155
  test.periods = 67
  cycle=12
  
  ts.training <- ts(tsdata$totalcost[1:train.periods], start = c(2001,1), end = c(2019,6), frequency = 12)
  
  ts.training.HWmodel <- HoltWinters(ts.training)
  
  ts.HWmodel <- HoltWinters(ts,
                            alpha=ts.training.HWmodel$alpha, 
                            beta=ts.training.HWmodel$beta, 
                            gamma=ts.training.HWmodel$gamma)
  
  forec = forecast(ts.HWmodel, 18)
  HW.plot = plot(ts.HWmodel)
  forecast.plot = plot(forec, main = "Holtwinter Seasonality Cost Forecast for 2019-2020")
  list(HW.plot, forecast.plot)
  
}
```

### 4. Priority Time Series



### 5. Efficiency Time Series

1. Request-Created Efficiency

**2. Workorder Completed Efficiency**

#Overall

```{r}
library(tidyverse)
library(TSstudio)
library(forecast)
library(lubridate)
dim(priority)

priority_overall_ts <- priority %>% mutate(year = year(actualcompletiondate))%>%  mutate(perc_totaleffi = totaleffi /round(mean(totaleffi))) %>% select( actualcompletiondate, perc_totaleffi)%>%arrange(actualcompletiondate)

which.max(priority_overall_ts$actualcompletiondate)

X<-ts(priority_overall_ts$perc_totaleffi, start = c(2001), end = c(2019), frequency = 12)
plot(X, ylab = "Total Efficiency (in %age)")
```






### Plumbing


```{r plumbing}

#install.packages(TSstudio)


unique(priority$craftgroup)

priority_plumbing_2 <- priority %>% filter(craftgroup =="PLUMBING/RESTROOM") %>% mutate(year = year(actualcompletiondate))%>%  mutate(perc_totaleffi = totaleffi /round(mean(totaleffi))) %>% select( actualcompletiondate, perc_totaleffi)

Y<-ts(priority_plumbing_2$perc_totaleffi, start = c(2001), end = c(2019), frequency = 12)
plot(Y)
sm <- ma(Y, order=3); lines(sm, col = "red")
#The moving average smoother averages the nearest order periods of each observation. As neighbouring observations of a time series are likely to be similar in value, averaging eliminates some of the randomness in the data, leaving a smooth trend-cycle component.

plot(Y)


#Split for total efficiency

plumbing_split<- ts_split(Y)
plumbing_training <- split_plumbing$train
plumbing_testing <- split_plumbing$test
plot(plumbing_training); plot(plumbing_testing)

 #DES
#  DES.training.Y<-HoltWinters(plumbing_training, gamma = F)
#  plot(DES.training.Y)
#  y.DESmodel<-HoltWinters(plumbing_testing, alpha = DES.training.Y$alpha, beta = DES.training.Y$beta, gamma = F)
# plot(y.DESmodel)
#  y.DESmodel$SSE


#Holtwinters
holtWinters.training.Y<-HoltWinters(plumbing_training)
plot(holtWinters.training.Y)

y.HWmodel <- HoltWinters(plumbing_testing, alpha = holtWinters.training.Y$alpha, beta = holtWinters.training.Y$beta, gamma = holtWinters.training.Y$gamma)
# x.HWmodel$fitted
plot(y.HWmodel)
y.HWmodel$SSE#Use this one

forecast_values.Y <- forecast(y.HWmodel, h=65) 
predict(holtWinters.training.Y , 65)
plot(forecast_values.Y, xlab = "Time", ylab = "Total Efficiency (in %age)")

```

###Others

```{r others}

priority_others_2<-priority %>% filter(craftgroup == "OTHER") %>% mutate(year = year(actualcompletiondate))%>%  mutate(perc_totaleffi = totaleffi/round(mean(totaleffi))) %>% select(actualcompletiondate, perc_totaleffi)

Y<-ts(priority_others_2$perc_totaleffi, start = c(2001,7), end = c(2019,12), frequency = 12)
plot(Y)
sm <- ma(Y, order=3); lines(sm, col = "red")

#The moving average smoother averages the nearest order periods of each observation. As neighbouring observations of a time series are likely to be similar in value, averaging eliminates some of the randomness in the data, leaving a smooth trend-cycle component.

plot(Y)

#Split for total efficiency

others_split <- ts_split(Y)
others_training <- others_split$train
others_testing <- others_split$test
plot(others_training); plot(others_testing)

#DES
DES.training.Y<-HoltWinters(others_training, gamma = F)
plot(DES.training.Y)
y.DESmodel<-HoltWinters(others_testing,alpha = DES.training.Y$alpha, beta = DES.training.Y$beta, gamma = F)
plot(y.DESmodel)
y.DESmodel$SSE


 #holtwinters
holtWinters.training.Y<-HoltWinters(others_training)
plot(holtWinters.training.Y)

y.HWmodel <- HoltWinters(others_testing, alpha = holtWinters.training.Y$alpha, beta = holtWinters.training.Y$beta, gamma = holtWinters.training.Y$gamma)
# x.HWmodel$fitted
 plot(y.HWmodel)
 y.HWmodel$SSE#use this one

#USE HW model for prediction
forecast_values.Y <- forecast(y.DESmodel, h=65)
predict(holtWinters.training.Y , 65)
plot(forecast_values.Y, xlab = "Time", ylab = "Total Efficiency (in %age)")

```


####Furnitures/Utilities/Appliances

```{r}
priority_furniture_2<-priority %>% filter(craftgroup=="FURNITURES/UTILITIES/APPLIANCES") %>% mutate(year = year(actualcompletiondate))%>%  mutate(perc_totaleffi = totaleffi/round(mean(totaleffi))) %>% select(actualcompletiondate, perc_totaleffi) %>% arrange(actualcompletiondate)

Y<-ts(priority_furniture_2$perc_totaleffi, start = c(2001,7), end = c(2019,12), frequency = 12)
plot(Y)
sm <- ma(Y, order=3); lines(sm, col = "red")

#The moving average smoother averages the nearest order periods of each observation. As neighbouring observations of a time series are likely to be similar in value, averaging eliminates some of the randomness in the data, leaving a smooth trend-cycle component.
plot(Y)



#Split for total efficiency

furniture_split <- ts_split(Y)
furniture_training <- furniture_split$train
furniture_testing <- furniture_split$test
plot(furniture_training); plot(furniture_testing)

#DES
 DES.training.Y<-HoltWinters(furniture_training, gamma = F)
 plot(DES.training.Y)
 y.DESmodel<-HoltWinters(furniture_testing,alpha = DES.training.Y$alpha, beta = DES.training.Y$beta, gamma = F)
 # plot(y.DESmodel)
 y.DESmodel$SSE



#holtwinters
HoltWinters.training.Y <- HoltWinters(furniture_training)
plot(holtWinters.training.Y)

y.HWmodel <- HoltWinters(furniture_testing, alpha = holtWinters.training.Y$alpha, beta = holtWinters.training.Y$beta, gamma = holtWinters.training.Y$gamma)
plot(y.HWmodel)
y.HWmodel$SSE#use this one

forecast_values.Y <- forecast(y.HWmodel, h = 65)
#forecast_values.Y<-abs(predict(holtWinters.training.Y, 65))
plot(forecast_values.Y,xlab = "Time", ylab = "Total Efficiency (in %age)")
```

####ELECTRICITY/ENERGY

```{r}
priority_electricity_2<-priority %>% filter(craftgroup=="ELECTRICITY/ENERGY") %>% mutate(year = year(actualcompletiondate))%>%  mutate(perc_totaleffi = totaleffi/round(mean(totaleffi))) %>% select(actualcompletiondate, perc_totaleffi) %>% arrange(actualcompletiondate)

Y <- ts(priority_electricity_2$perc_totaleffi, start = c(2001), end = c(2019), frequency = 12)
plot(Y)
sm <- ma(Y, order=3); lines(sm, col = "red")

#The moving average smoother averages the nearest order periods of each observation. As neighbouring observations of a time series are likely to be similar in value, averaging eliminates some of the randomness in the data, leaving a smooth trend-cycle component.

plot(Y)


#Split for total efficiency

electricity_split <- ts_split(Y)
electricity_training <- electricity_split$train
electricity_testing <- electricity_split$test
plot(electricity_training); plot(electricity_testing)

#DES
DES.training.Y<-HoltWinters(electricity_training, gamma = F)
plot(DES.training.Y)
y.DESmodel<-HoltWinters(electricity_testing,alpha = DES.training.Y$alpha, beta = DES.training.Y$beta, gamma = F)
plot(y.DESmodel)
y.DESmodel$SSE




#holtwinters
HoltWinters.training.Y <- HoltWinters(electricity_training)
plot(holtWinters.training.Y)

y.HWmodel <- HoltWinters(electricity_testing, alpha = holtWinters.training.Y$alpha, beta = holtWinters.training.Y$beta, gamma = holtWinters.training.Y$gamma)
plot(y.HWmodel)
y.HWmodel$SSE#use this one

forecast_values.Y<- forecast(y.HWmodel, h = 65)
#forecast_values.Y<-abs(predict(holtWinters.training.Y, 65))
plot(forecast_values.Y,xlab = "Time", ylab = "Total Efficiency (in %age)")
```

####Outdoors

```{r Outdoors}
priority_outdoors_2<-priority %>% filter(craftgroup=="OUTDOORS") %>% mutate(year = year(actualcompletiondate))%>%  mutate(perc_totaleffi = totaleffi/round(mean(totaleffi))) %>% select(actualcompletiondate, perc_totaleffi) %>% arrange(actualcompletiondate)

Y<-ts(priority_outdoors_2$perc_totaleffi, start = c(2001), end = c(2019), frequency = 12)
plot(Y)
sm <- ma(Y, order=3); lines(sm, col = "red")

#The moving average smoother averages the nearest order periods of each observation. As neighbouring observations of a time series are likely to be similar in value, averaging eliminates some of the randomness in the data, leaving a smooth trend-cycle component.

#Split for total efficiency

outdoors_split <- ts_split(Y)
outdoors_training <- outdoors_split$train
outdoors_testing <- outdoors_split$test
#plot(outdoors_training); plot(outdoors_testing)

#DES
# DES.training.Y<-HoltWinters(outdoors_training, gamma = F)
# plot(DES.training.Y)
# y.DESmodel<-HoltWinters(outdoors_testing,alpha = DES.training.Y$alpha, beta = DES.training.Y$beta, gamma = F)
# # plot(y.DESmodel)
# y.DESmodel$SSE


#Holtwinters
HoltWinters.training.Y <- HoltWinters(outdoors_training)
plot(holtWinters.training.Y)

y.HWmodel <- HoltWinters(outdoors_testing, alpha = holtWinters.training.Y$alpha, beta = holtWinters.training.Y$beta, gamma = holtWinters.training.Y$gamma)
y.HWmodel$SSE #Use this one
 plot(y.HWmodel)


forecast_values.Y<- forecast(y.HWmodel, h = 65)
#forecast_values.Y<-abs(predict(holtWinters.training.Y, 65))
plot(forecast_values.Y, xlab = "Time", ylab = "Total Efficiency (in %age)")
```


####HEALTH/SAFETY/SECURITY

```{r health}
priority_health_2<-priority %>% filter(craftgroup=="HEALTH/SAFETY/SECURITY") %>% mutate(year = year(actualcompletiondate))%>%  mutate(perc_totaleffi = totaleffi/round(mean(totaleffi))) %>% select(actualcompletiondate, perc_totaleffi) %>% arrange(actualcompletiondate)

Y<-ts(priority_health_2$perc_totaleffi, start = c(2001), end = c(2019), frequency = 12)
plot(Y)
sm <- ma(Y, order=3); lines(sm, col = "red")

#The moving average smoother averages the nearest order periods of each observation. As neighbouring observations of a time series are likely to be similar in value, averaging eliminates some of the randomness in the data, leaving a smooth trend-cycle component.

plot(Y)


#Split for total efficiency

health_split <- ts_split(Y)
health_training <- health_split$train
health_testing <- health_split$test
plot(health_training); plot(health_testing)

#DES
DES.training.Y<-HoltWinters(health_training, gamma = F)
plot(DES.training.Y)
y.DESmodel<-HoltWinters(health_testing,alpha = DES.training.Y$alpha, beta = DES.training.Y$beta, gamma = F)
# plot(y.DESmodel)
y.DESmodel$SSE#use this one


# Holtwinters
# HoltWinters.training.Y <- HoltWinters(health_training)
# plot(holtWinters.training.Y)
# 
# y.HWmodel <- HoltWinters(health_testing, alpha = holtWinters.training.Y$alpha, beta = holtWinters.training.Y$beta, gamma = holtWinters.training.Y$gamma)
# plot(y.HWmodel)
# y.HWmodel$SSE

forecast_values.Y <- forecast(y.DESmodel, h = 65)
#forecast_values.Y<-abs(predict(holtWinters.training.Y, 65))
plot(forecast_values.Y, xlab = "Time", ylab = "Total Efficiency (in %age)")
```

####EVENT/RECREATION/F&B

```{r}
priority_events_2<-priority %>% filter(craftgroup=="EVENT/RECREATION/F&B") %>% mutate(year = year(actualcompletiondate))%>%  mutate(perc_totaleffi = totaleffi/round(mean(totaleffi))) %>% select(actualcompletiondate, perc_totaleffi) %>% arrange(actualcompletiondate)

Y<-ts(priority_events_2$perc_totaleffi, start = c(2001), end = c(2019), frequency = 12)
plot(Y)
sm <- ma(Y, order=3); lines(sm, col = "red")

#The moving average smoother averages the nearest order periods of each observation. As neighbouring observations of a time series are likely to be similar in value, averaging eliminates some of the randomness in the data, leaving a smooth trend-cycle component.

plot(Y)



#Split for total efficiency

events_split <- ts_split(Y)
events_training <- events_split$train
events_testing <- events_split$test
plot(events_training); plot(events_testing)

#DES
# DES.training.Y<-HoltWinters(events_training, gamma = F)
# plot(DES.training.Y)
# y.DESmodel<-HoltWinters(events_testing,alpha = DES.training.Y$alpha, beta = DES.training.Y$beta, gamma = F)
# # plot(y.DESmodel)
# y.DESmodel$SSE


#Holtwinters
HoltWinters.training.Y <- HoltWinters(events_training)
plot(holtWinters.training.Y)

y.HWmodel <- HoltWinters(events_testing, alpha = holtWinters.training.Y$alpha, beta = holtWinters.training.Y$beta, gamma = holtWinters.training.Y$gamma)
plot(y.HWmodel)
y.HWmodel$SSE#Use this one

forecast_values.Y<- forecast(y.HWmodel, h = 65)
#forecast_values.Y<-abs(predict(HoltWinters.training.Y, 65))
plot(forecast_values.Y, xlab = "Time", ylab = "Total Efficiency (in %age)")
```

##CLEANING/SANITIZATION

```{r cleaning}
priority_cleaning_2<-priority %>% filter(craftgroup=="CLEANING/SANITIZATION") %>% mutate(year = year(actualcompletiondate))%>%  mutate(perc_totaleffi = totaleffi/round(mean(totaleffi))) %>% select(actualcompletiondate, perc_totaleffi) %>% arrange(actualcompletiondate)

Y<-ts(priority_cleaning_2$perc_totaleffi, start = c(2001), end = c(2019), frequency = 12)
plot(Y)
sm <- ma(Y, order=3); lines(sm, col = "red")

#The moving average smoother averages the nearest order periods of each observation. As neighbouring observations of a time series are likely to be similar in value, averaging eliminates some of the randomness in the data, leaving a smooth trend-cycle component.

plot(Y)


#Split for total efficiency

cleaning_split <- ts_split(Y)
cleaning_training <- cleaning_split$train
cleaning_testing <- cleaning_split$test
plot(cleaning_training); plot(cleaning_testing)

#DES
DES.training.Y <- HoltWinters(cleaning_training, gamma = F)
plot(DES.training.Y)
y.DESmodel<-HoltWinters(cleaning_testing,alpha = DES.training.Y$alpha, beta = DES.training.Y$beta, gamma = F)
plot(y.DESmodel)
y.DESmodel$SSE #use this one




#Holtwinters
# HoltWinters.training.Y <- HoltWinters(cleaning_training)
# plot(holtWinters.training.Y)
# 
# y.HWmodel <- HoltWinters(cleaning_testing, alpha = holtWinters.training.Y$alpha, beta = holtWinters.training.Y$beta, gamma = holtWinters.training.Y$gamma)
# plot(y.HWmodel)
# y.HWmodel$SSE


forecast_values.Y<- forecast(y.DESmodel, h = 65)
#forecast_values.Y<-abs(predict(HoltWinters.training.Y, 65))
plot(forecast_values.Y, xlab = "Time", ylab = "Total Efficiency (in %age)")
```



####CONSTRUCTION/BUILDING
```{r construction}
priority_construction_2<-priority %>% filter(craftgroup=="CONSTRUCTION/BUILDING") %>% mutate(year = year(actualcompletiondate))%>%  mutate(perc_totaleffi = totaleffi/round(mean(totaleffi))) %>% select(actualcompletiondate, perc_totaleffi) %>% arrange(actualcompletiondate)

Y<-ts(priority_construction_2$perc_totaleffi, start = c(2001), end = c(2019), frequency = 12)
plot(Y)
sm <- ma(Y, order=3); lines(sm, col = "red")

#The moving average smoother averages the nearest order periods of each observation. As neighbouring observations of a time series are likely to be similar in value, averaging eliminates some of the randomness in the data, leaving a smooth trend-cycle component.

plot(Y)


#Split for total efficiency

construction_split <- ts_split(Y)
construction_training <- construction_split$train
construction_testing <- construction_split$test
plot(construction_training); plot(construction_testing)

#DES
# DES.training.Y <- HoltWinters(construction_training, gamma = F)
# plot(DES.training.Y)
# y.DESmodel <- HoltWinters(construction_testing,alpha = DES.training.Y$alpha, beta = DES.training.Y$beta, gamma = F)
# plot(y.DESmodel)
# y.DESmodel$SSE


#Holtwinters
HoltWinters.training.Y <- HoltWinters(construction_training)
plot(holtWinters.training.Y)

y.HWmodel <- HoltWinters(construction_testing, alpha = holtWinters.training.Y$alpha, beta = holtWinters.training.Y$beta, gamma = holtWinters.training.Y$gamma)
plot(y.HWmodel)
y.HWmodel$SSE#Use this one


forecast_values.Y<- forecast(y.HWmodel, h = 65)
#forecast_values.Y<-abs(predict(HoltWinters.training.Y, 65))
plot(forecast_values.Y, xlab = "Time", ylab = "Total Efficiency (in %age)")
```

####UNCLEAR/TBD

```{r unclear}
priority_unclear_2<-priority %>% filter(craftgroup=="UNCLEAR/TBD") %>% mutate(year = year(actualcompletiondate))%>%  mutate(perc_totaleffi = totaleffi/round(mean(totaleffi))) %>% select(actualcompletiondate, perc_totaleffi) %>% arrange(actualcompletiondate)

Y<-ts(priority_unclear_2$perc_totaleffi, start = c(2001), end = c(2019), frequency = 12)
plot(Y)
sm <- ma(Y, order=3); lines(sm, col = "red")

#The moving average smoother averages the nearest order periods of each observation. As neighbouring observations of a time series are likely to be similar in value, averaging eliminates some of the randomness in the data, leaving a smooth trend-cycle component.

plot(Y)
#Split for total efficiency

unclear_split <- ts_split(Y)
unclear_training <- unclear_split$train
unclear_testing <- unclear_split$test
plot(unclear_training); plot(unclear_testing)

#DES
DES.training.Y <- HoltWinters(unclear_training, gamma = F)
plot(DES.training.Y)
y.DESmodel <- HoltWinters(unclear_testing,alpha = DES.training.Y$alpha, beta = DES.training.Y$beta, gamma = F)
plot(y.DESmodel)
y.DESmodel$SSE#Use this model




#holtwinters
# HoltWinters.training.Y <- HoltWinters(unclear_training)
# plot(holtWinters.training.Y)
# 
# y.HWmodel <- HoltWinters(unclear_testing, alpha = holtWinters.training.Y$alpha, beta = holtWinters.training.Y$beta, gamma = holtWinters.training.Y$gamma)
# y.HWmodel$SSE
# plot(y.HWmodel)


forecast_values.Y <- forecast(y.DESmodel, h = 65)
#forecast_values.Y<-abs(predict(HoltWinters.training.Y, 65))
plot(forecast_values.Y, xlab = "Time", ylab = "Total Efficiency (in %age)")
```


####IT/NETWORK
```{r ITNetwork}
priority_network_2<-priority %>% filter(craftgroup=="IT/NETWORK") %>% mutate(year = year(actualcompletiondate))%>%  mutate(perc_totaleffi = totaleffi/round(mean(totaleffi))) %>% select(actualcompletiondate, perc_totaleffi) %>% arrange(actualcompletiondate)

Y<-ts(priority_network_2$perc_totaleffi, start = c(2001), end = c(2019), frequency = 12)
plot(Y)
sm <- ma(Y, order=3); lines(sm, col = "red")

#The moving average smoother averages the nearest order periods of each observation. As neighbouring observations of a time series are likely to be similar in value, averaging eliminates some of the randomness in the data, leaving a smooth trend-cycle component.

plot(Y)
#Split for total efficiency

network_split <- ts_split(Y)
network_training <- network_split$train
network_testing <- network_split$test
plot(network_training); plot(network_testing)

#DES
DES.training.Y <- HoltWinters(network_training, gamma = F)
plot(DES.training.Y)
y.DESmodel <- HoltWinters(network_testing,alpha = DES.training.Y$alpha, beta = DES.training.Y$beta, gamma = F)
plot(y.DESmodel)
y.DESmodel$SSE#use this one




#holtwinters
# HoltWinters.training.Y <- HoltWinters(network_training)
# plot(holtWinters.training.Y)
# 
# y.HWmodel <- HoltWinters(network_testing, alpha = holtWinters.training.Y$alpha, beta = holtWinters.training.Y$beta, gamma = holtWinters.training.Y$gamma)
# plot(y.HWmodel)
# y.HWmodel$SSE


forecast_values.Y<- forecast(y.DESmodel, h = 65)
#forecast_values.Y<-abs(predict(HoltWinters.training.Y, 65))
plot(forecast_values.Y, xlab = "Time", ylab = "Total Efficiency (in %age)")
```

#### VEHICLE/TRANSPORTATION/DELIVERY

```{r transport}
priority_transport_2<-priority %>% filter(craftgroup=="VEHICLE/TRANSPORTATION/DELIVERY") %>% mutate(year = year(actualcompletiondate))%>%  mutate(perc_totaleffi = totaleffi/round(mean(totaleffi))) %>% select(actualcompletiondate, perc_totaleffi) %>% arrange(actualcompletiondate)

Y<-ts(priority_transport_2$perc_totaleffi, start = c(2001), end = c(2019), frequency = 12)
plot(Y)
sm <- ma(Y, order=3); lines(sm, col = "red")

#The moving average smoother averages the nearest order periods of each observation. As neighbouring observations of a time series are likely to be similar in value, averaging eliminates some of the randomness in the data, leaving a smooth trend-cycle component.

plot(Y)

#Split for total efficiency

transport_split <- ts_split(Y)
transport_training <- transport_split$train
transport_testing <- transport_split$test
plot(transport_training); plot(transport_testing)


#DES
DES.training.Y <- HoltWinters(transport_training, gamma = F)
plot(DES.training.Y)
y.DESmodel <- HoltWinters(transport_testing,alpha = DES.training.Y$alpha, beta = DES.training.Y$beta, gamma = F)
plot(y.DESmodel)
y.DESmodel$SSE


#Holtwinters
# HoltWinters.training.Y <- HoltWinters(transport_training, )
# plot(holtWinters.training.Y)
# y.HWmodel <- HoltWinters(transport_testing, alpha = holtWinters.training.Y$alpha, beta = holtWinters.training.Y$beta, gamma = holtWinters.training.Y$gamma)
# plot(y.HWmodel)
# y.HWmodel$SSE



forecast_values.Y <- forecast(y.DESmodel, h = 65)
#forecast_values.Y<-abs(predict(HoltWinters.training.Y, 65))
plot(forecast_values.Y,xlab = "Time", ylab = "Total Efficiency (in %age)")
```

####PLANT

```{r plant}
priority_plant_2<-priority %>% filter(craftgroup=="PLANT/MATERIALS") %>% mutate(year = year(actualcompletiondate))%>%  mutate(perc_totaleffi = totaleffi/round(mean(totaleffi))) %>% select(actualcompletiondate, perc_totaleffi) %>% arrange(actualcompletiondate)

Y<-ts(priority_plant_2$perc_totaleffi, start = c(2001), end = c(2019), frequency = 12)
plot(Y)
sm <- ma(Y, order=3); lines(sm, col = "red")

#The moving average smoother averages the nearest order periods of each observation. As neighbouring observations of a time series are likely to be similar in value, averaging eliminates some of the randomness in the data, leaving a smooth trend-cycle component.

plot(Y)
#Split for total efficiency

plant_split <- ts_split(Y)
plant_training <- plant_split$train
plant_testing <- plant_split$test
plot(plant_training); plot(plant_testing)

#DES
# DES.training.Y <- HoltWinters(plant_training, gamma = F)
# plot(DES.training.Y)
# y.DESmodel <- HoltWinters(plant_testing, alpha = DES.training.Y$alpha, beta = DES.training.Y$beta, gamma = F)
# plot(y.DESmodel)
# y.DESmodel$SSE


#Holtwinters
HoltWinters.training.Y <- HoltWinters(plant_training)
plot(holtWinters.training.Y)

y.HWmodel <- HoltWinters(plant_testing, alpha = holtWinters.training.Y$alpha, beta = holtWinters.training.Y$beta, gamma = holtWinters.training.Y$gamma)
plot(y.HWmodel)
y.HWmodel$SSE#Use this one

forecast_values.Y<- forecast(y.HWmodel, h = 65)
#forecast_values.Y<-abs(predict(HoltWinters.training.Y, 65))
plot(forecast_values.Y, xlab = "Time", ylab = "Total Efficiency (in %age)")
```


####ADMIN

```{r admin}
priority_admin_2<-priority %>% filter(craftgroup=="VEHICLE/TRANSPORTATION/DELIVERY") %>% mutate(year = year(actualcompletiondate))%>%  mutate(perc_totaleffi = totaleffi/round(mean(totaleffi))) %>% select(actualcompletiondate, perc_totaleffi) %>% arrange(actualcompletiondate)

Y<-ts(priority_admin_2$perc_totaleffi, start = c(2001), end = c(2019), frequency = 12)
plot(Y)
sm <- ma(Y, order=3); lines(sm, col = "red")

#The moving average smoother averages the nearest order periods of each observation. As neighbouring observations of a time series are likely to be similar in value, averaging eliminates some of the randomness in the data, leaving a smooth trend-cycle component.

plot(Y)

#Split for total efficiency

admin_split <- ts_split(Y)
admin_training <- admin_split$train
admin_testing <- admin_split$test
plot(admin_training); plot(admin_testing)

#DES
DES.training.Y <- HoltWinters(admin_training, gamma = F)
plot(DES.training.Y)
y.DESmodel <- HoltWinters(admin_testing, alpha = DES.training.Y$alpha, beta = DES.training.Y$beta, gamma = F)
plot(y.DESmodel)
y.DESmodel$SSE#use this one


#Holtwinters
HoltWinters.training.Y <- HoltWinters(admin_training)
plot(holtWinters.training.Y)

y.HWmodel <- HoltWinters(admin_testing, alpha = holtWinters.training.Y$alpha, beta = holtWinters.training.Y$beta, gamma = holtWinters.training.Y$gamma)
plot(y.HWmodel)
y.HWmodel$SSE


forecast_values.Y<- forecast(y.DESmodel, h = 65)
#forecast_values.Y<-abs(predict(HoltWinters.training.Y, 65))
plot(forecast_values.Y, xlab = "Time", ylab = "Total Efficiency (in %age)")
```


####PREVENTIVE/SCHEDULED
```{r ps}
priority_ps_2<-priority %>% filter(craftgroup=="PREVENTIVE/SCHEDULED") %>% mutate(year = year(actualcompletiondate))%>%  mutate(perc_totaleffi = totaleffi/round(mean(totaleffi))) %>% select(actualcompletiondate, perc_totaleffi) %>% arrange(actualcompletiondate)

Y<-ts(priority_ps_2$perc_totaleffi, start = c(2001), end = c(2019), frequency = 12)
plot(Y)
sm <- ma(Y, order=3); lines(sm, col = "red")

#The moving average smoother averages the nearest order periods of each observation. As neighbouring observations of a time series are likely to be similar in value, averaging eliminates some of the randomness in the data, leaving a smooth trend-cycle component.

plot(Y)

#Split for total efficiency

ps_split <- ts_split(Y)
ps_training <- ps_split$train
ps_testing <- ps_split$test
plot(ps_training); plot(ps_testing)

#DES
DES.training.Y <- HoltWinters(ps_training, gamma = F)
plot(DES.training.Y)
y.DESmodel <- HoltWinters(ps_testing, alpha = DES.training.Y$alpha, beta = DES.training.Y$beta, gamma = F)
plot(y.DESmodel)
y.DESmodel$SSE

#Holtwinters
# HoltWinters.training.Y <- HoltWinters(ps_training)
# plot(holtWinters.training.Y)
# y.HWmodel <- HoltWinters(ps_testing, alpha = holtWinters.training.Y$alpha, beta = holtWinters.training.Y$beta,gamma =  holtWinters.training.Y$gamma)
# plot(y.HWmodel)
# y.HWmodel$SSE


forecast_values.Y <- forecast(y.DESmodel, h = 65)
#forecast_values.Y<-abs(predict(HoltWinters.training.Y, 65))
plot(forecast_values.Y, xlab = "Time", ylab = "Total Efficiency (in %age)")
```

####SOS


```{r SOS}
priority_sos_2<-priority %>% filter(craftgroup=="SOS") %>% mutate(year = year(actualcompletiondate))%>%  mutate(perc_totaleffi = totaleffi/round(mean(totaleffi))) %>% select(actualcompletiondate, perc_totaleffi) %>% arrange(actualcompletiondate)

Y<-ts(priority_sos_2$perc_totaleffi, start = c(2001), end = c(2019), frequency = 12)
plot(Y)
sm <- ma(Y, order=3); lines(sm, col = "red")

#The moving average smoother averages the nearest order periods of each observation. As neighbouring observations of a time series are likely to be similar in value, averaging eliminates some of the randomness in the data, leaving a smooth trend-cycle component.

plot(Y)

#Split for total efficiency

sos_split <- ts_split(Y)
sos_training <- sos_split$train
sos_testing <- sos_split$test
plot(sos_training); plot(sos_testing)

#DES
# DES.training.Y <- HoltWinters(sos_training, gamma = F)
# plot(DES.training.Y)
# y.DESmodel <- HoltWinters(sos_testing, alpha = DES.training.Y$alpha, beta = DES.training.Y$beta, gamma = F)
# plot(y.DESmodel)
# y.DESmodel$SSE


#Holtwinters
HoltWinters.training.Y <- HoltWinters(sos_training)
plot(holtWinters.training.Y)

y.HWmodel <- HoltWinters(sos_testing, alpha = holtWinters.training.Y$alpha, beta = holtWinters.training.Y$beta, gamma = holtWinters.training.Y$gamma)
plot(y.HWmodel)
y.HWmodel$SSE#use this one. More accurate plot

forecast_values.Y<- forecast(y.HWmodel, h = 65)
#forecast_values.Y<-abs(predict(HoltWinters.training.Y, 65))
plot(forecast_values.Y, xlab = "Time", ylab = "Total Efficiency (in %age)")
```

####INSPECTION

```{r inspection}
priority_inspection_2<-priority %>% filter(craftgroup=="INSPECTION") %>% mutate(year = year(actualcompletiondate))%>%  mutate(perc_totaleffi = totaleffi/round(mean(totaleffi))) %>% select(actualcompletiondate, perc_totaleffi) %>% arrange(actualcompletiondate)

Y<-ts(priority_inspection_2$perc_totaleffi, start = c(2001), end = c(2019), frequency = 12)
plot(Y)
sm <- ma(Y, order=3); lines(sm, col = "red")

#The moving average smoother averages the nearest order periods of each observation. As neighbouring observations of a time series are likely to be similar in value, averaging eliminates some of the randomness in the data, leaving a smooth trend-cycle component.

plot(Y)


#Split for total efficiency

inspection_split <- ts_split(Y)
inspection_training <-inspection_split$train
inspection_testing <-inspection_split$test
plot(inspection_training); plot(inspection_testing)

#DES
# DES.training.Y <- HoltWinters(inspection_training, gamma = F)
# plot(DES.training.Y)
# y.DESmodel <- HoltWinters(inspection_testing, alpha = DES.training.Y$alpha, beta = DES.training.Y$beta, gamma = F)
# plot(y.DESmodel)
# y.DESmodel$SSE

#holtwinters
HoltWinters.training.Y <- HoltWinters(inspection_training)
plot(holtWinters.training.Y)

y.HWmodel <- HoltWinters(inspection_testing, alpha = holtWinters.training.Y$alpha, beta = holtWinters.training.Y$beta, gamma = holtWinters.training.Y$gamma)
plot(y.HWmodel); y.HWmodel$SSE#Use this


forecast_values.Y<- forecast(y.HWmodel, h = 65)
#forecast_values.Y<-abs(predict(HoltWinters.training.Y, 65))
plot(forecast_values.Y, xlab = "Time", ylab = "Total Efficiency (in %age)")
```


####CONTRACT

```{r contract}
priority_contract_2<-priority %>% filter(craftgroup=="CONTRACT") %>% mutate(year = year(actualcompletiondate))%>%  mutate(perc_totaleffi = totaleffi/round(mean(totaleffi))) %>% select(actualcompletiondate, perc_totaleffi) %>% arrange(actualcompletiondate)

Y<-ts(priority_contract_2$perc_totaleffi, start = c(2001), end = c(2019), frequency = 12)
plot(Y)
sm <- ma(Y, order=3); lines(sm, col = "red")

#The moving average smoother averages the nearest order periods of each observation. As neighbouring observations of a time series are likely to be similar in value, averaging eliminates some of the randomness in the data, leaving a smooth trend-cycle component.

plot(Y)

#Split for total efficiency

contract_split <- ts_split(Y)
contract_training <-contract_split$train
contract_testing <-contract_split$test
plot(contract_training); plot(contract_testing)

#DES
# DES.training.Y <- HoltWinters(contract_training, gamma = F)
# plot(DES.training.Y)
# y.DESmodel <- HoltWinters(contract_testing, alpha = DES.training.Y$alpha, beta = DES.training.Y$beta, gamma = F)
# plot(y.DESmodel)
# y.DESmodel$SSE



#Holtwinters
HoltWinters.training.Y <- HoltWinters(contract_training)
plot(holtWinters.training.Y)

y.HWmodel <- HoltWinters(contract_testing, alpha = holtWinters.training.Y$alpha, beta = holtWinters.training.Y$beta, gamma = holtWinters.training.Y$gamma); y.HWmodel$SSE
plot(y.HWmodel)#Use this one


forecast_values.Y<- forecast(y.HWmodel, h = 65)
#forecast_values.Y<-abs(predict(HoltWinters.training.Y, 65))
plot(forecast_values.Y, xlab = "Time", ylab = "Total Efficiency (in %age)")
```

####CODES

```{r codes}
priority_codes_2<-priority %>% filter(craftgroup=="CODES") %>% mutate(year = year(actualcompletiondate))%>%  mutate(perc_totaleffi = totaleffi/round(mean(totaleffi))) %>% select(actualcompletiondate, perc_totaleffi) %>% arrange(actualcompletiondate)

Y<-ts(priority_codes_2$perc_totaleffi, start = c(2001), end = c(2019), frequency = 12)
plot(Y)
sm <- ma(Y, order=3); lines(sm, col = "red")

#The moving average smoother averages the nearest order periods of each observation. As neighbouring observations of a time series are likely to be similar in value, averaging eliminates some of the randomness in the data, leaving a smooth trend-cycle component.

plot(Y)

#Split for total efficiency

codes_split <- ts_split(Y)
codes_training <-codes_split$train
codes_testing <-codes_split$test
plot(codes_training); plot(codes_testing)

#DES
DES.training.Y <- HoltWinters(codes_training, gamma = F)
plot(DES.training.Y)
y.DESmodel <- HoltWinters(codes_testing, alpha = DES.training.Y$alpha, beta = DES.training.Y$beta, gamma = F)
plot(y.DESmodel)
y.DESmodel$SSE



#holtwinters
HoltWinters.training.Y <- HoltWinters(codes_training)
plot(holtWinters.training.Y)

y.HWmodel <- HoltWinters(codes_testing, alpha = holtWinters.training.Y$alpha, beta= holtWinters.training.Y$beta, gamma = holtWinters.training.Y$gamma)
plot(y.HWmodel);y.HWmodel$SSE


forecast_values.Y<- forecast(y.HWmodel, h = 65)
#forecast_values.Y<-abs(predict(HoltWinters.training.Y, 65))
```









